"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const decompress_1 = __importDefault(require("decompress"));
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
class Download {
    constructor(url, options = {}) {
        this.url = url;
        this.options = options;
        this.options.dest = this.options.dest || process.cwd();
        this.options.logger = this.options.logger || console;
        this.options.filename = this.options.filename || constants_1.DEFAULT_FILENAME;
        this.validate();
    }
    validate() {
        if (!this.url) {
            throw new Error('url is required');
        }
        if (!this.url.toLowerCase().startsWith('http')) {
            throw new Error('url must be http or https');
        }
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            const { logger } = this.options;
            const uri = new url_1.URL(this.url);
            logger.log(`Downloading[${chalk_1.default.green(decodeURIComponent(uri.pathname))}]...`);
            try {
                const filePath = yield this.doDownload(this.url);
                yield this.doDecompress(filePath);
                logger.log('Download successfully');
            }
            catch (error) {
                logger.error('Download failed');
            }
        });
    }
    doDecompress(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const { dest } = this.options;
            const _a = this.options, { extract, filename } = _a, restOpts = __rest(_a, ["extract", "filename"]);
            if (!extract)
                return;
            // node-v12.22.1: end of central directory record signature not found
            for (let index = 0; index < 3; index++) {
                try {
                    yield (0, decompress_1.default)(filePath, dest, restOpts);
                    break;
                }
                catch (error) {
                    if (index === 2) {
                        throw error;
                    }
                }
            }
            yield fs_extra_1.default.unlink(filePath);
        });
    }
    doDownload(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const dest = this.options.dest;
            const filename = this.options.filename;
            const uri = new url_1.URL(url);
            const pkg = url.toLowerCase().startsWith('https:') ? https_1.default : http_1.default;
            return new Promise((resolve, reject) => {
                pkg.get(uri.href).on('response', (response) => {
                    fs_extra_1.default.ensureDirSync(dest);
                    const filePath = path_1.default.join(dest, filename);
                    if (response.statusCode === 200) {
                        const file = fs_extra_1.default.createWriteStream(filePath);
                        file.on('open', () => {
                            response
                                .on('data', (chunk) => {
                                file.write(chunk);
                            })
                                .on('end', () => {
                                file.end();
                                resolve(filePath);
                            })
                                .on('error', (err) => {
                                file.destroy();
                                fs_extra_1.default.unlink(dest, () => reject(err));
                            });
                        });
                    }
                    else if (response.statusCode === 302 || response.statusCode === 301) {
                        // Recursively follow redirects, only a 200 will resolve.
                        this.doDownload(response.headers.location).then((val) => resolve(val));
                    }
                    else {
                        reject({
                            code: response.statusCode,
                            message: response.statusMessage,
                        });
                    }
                });
            });
        });
    }
}
exports.default = (url, options) => __awaiter(void 0, void 0, void 0, function* () {
    const download = new Download(url, options);
    return yield download.run();
});
//# sourceMappingURL=index.js.map